<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reachy Mini - Blockly Controller</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/10.4.3/blockly.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f0f1a;
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    header h1 { font-size: 1.3rem; display: flex; align-items: center; gap: 8px; }
    .status { display: flex; align-items: center; gap: 8px; font-size: 13px; }
    .status-dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: #ef4444;
      transition: all 0.3s;
    }
    .status-dot.connected { background: #22c55e; box-shadow: 0 0 8px #22c55e; }
    .controls { display: flex; gap: 8px; margin-left: auto; flex-wrap: wrap; }
    button {
      background: rgba(255,255,255,0.15);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }
    button:hover { background: rgba(255,255,255,0.25); transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button.primary { background: #22c55e; border-color: #16a34a; }
    button.primary:hover { background: #16a34a; }
    button.danger { background: #ef4444; border-color: #dc2626; }
    button.danger:hover { background: #dc2626; }
    main { flex: 1; display: flex; overflow: hidden; }
    #blocklyDiv { flex: 1; height: 100%; }
    .sidebar {
      width: 340px;
      background: #1a1a2e;
      border-left: 1px solid #2a2a4a;
      display: flex;
      flex-direction: column;
    }
    .sidebar-header {
      padding: 10px 14px;
      background: #232340;
      font-weight: 600;
      font-size: 12px;
      color: #888;
      border-bottom: 1px solid #2a2a4a;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .code-output {
      flex: 1;
      padding: 12px;
      overflow: auto;
      font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
      font-size: 11px;
      line-height: 1.5;
      white-space: pre-wrap;
      color: #a0a0c0;
      background: #12121f;
    }
    .console { height: 200px; border-top: 1px solid #2a2a4a; display: flex; flex-direction: column; }
    .console-output {
      flex: 1; padding: 10px; overflow-y: auto;
      font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
      font-size: 11px;
      background: #0a0a14;
    }
    .console-output div { padding: 2px 0; border-bottom: 1px solid #1a1a2a; }
    .console-output .log { color: #a0a0c0; }
    .console-output .error { color: #f87171; }
    .console-output .success { color: #4ade80; }
    .console-output .warn { color: #fbbf24; }
    .console-output .info { color: #60a5fa; }
    .motor-status {
      padding: 10px;
      background: #12121f;
      border-bottom: 1px solid #2a2a4a;
      font-size: 11px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
    }
    .motor-badge {
      background: #232340;
      padding: 4px 8px;
      border-radius: 4px;
      text-align: center;
    }
    .motor-badge.active { background: #22c55e33; border: 1px solid #22c55e; }
    .motor-badge.error { background: #ef444433; border: 1px solid #ef4444; color: #f87171; }
    .motor-badge span { display: block; font-size: 10px; color: #666; }
    .tabs { display: flex; background: #232340; }
    .tab {
      flex: 1;
      padding: 8px;
      text-align: center;
      cursor: pointer;
      font-size: 12px;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .tab:hover { background: #2a2a50; }
    .tab.active { border-bottom-color: #667eea; color: #667eea; }
    .tab-content { display: none; flex: 1; flex-direction: column; overflow: hidden; }
    .tab-content.active { display: flex; }
    
    /* Blockly toolbox text fix */
    .blocklyTreeLabel, .blocklyToolboxCategory {
      color: #000000 !important;
    }
    .blocklyTreeRow:hover {
      background-color: rgba(255,255,255,0.1) !important;
    }
  </style>
</head>
<body>
  <header>
    <h1>ü§ñ Reachy Mini</h1>
    <div class="status">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Disconnected</span>
    </div>
    <div class="controls">
      <button id="connectBtn" onclick="toggleConnection()">üîå Connect</button>
      <button onclick="checkMotors()">üîç Check</button>
      <button onclick="enableAllTorque()">‚ö° Enable All</button>
      <button onclick="disableAllTorque()">üí§ Disable All</button>
      <button onclick="rebootAllMotors()">üîÑ Reboot All</button>
      <button class="primary" onclick="runCode()">‚ñ∂ Run</button>
      <button class="danger" onclick="stopCode()">‚¨õ Stop</button>
      <button onclick="saveWorkspace()">üíæ Save</button>
      <button onclick="loadWorkspace()">üìÇ Load</button>
    </div>
  </header>
  
  <main>
    <div id="blocklyDiv"></div>
    <div class="sidebar">
      <div class="sidebar-header">Motor Status</div>
      <div class="motor-status" id="motorStatus">
        <div class="motor-badge" id="motor11">M11<span>--</span></div>
        <div class="motor-badge" id="motor12">M12<span>--</span></div>
        <div class="motor-badge" id="motor13">M13<span>--</span></div>
        <div class="motor-badge" id="motor14">M14<span>--</span></div>
        <div class="motor-badge" id="motor15">M15<span>--</span></div>
        <div class="motor-badge" id="motor16">M16<span>--</span></div>
        <div class="motor-badge" id="motor17">M17<span>--</span></div>
        <div class="motor-badge" id="motor18">M18<span>--</span></div>
      </div>
      <div class="tabs">
        <div class="tab" onclick="switchTab('code')">Code</div>
        <div class="tab active" onclick="switchTab('console')">Console</div>
      </div>
      <div class="tab-content" id="codeTab">
        <div class="sidebar-header">Generated JavaScript</div>
        <div class="code-output" id="codeOutput">// Drag blocks here...</div>
      </div>
      <div class="tab-content active" id="consoleTab">
        <div class="sidebar-header">Console Output</div>
        <div class="console-output" id="consoleOutput"></div>
      </div>
    </div>
  </main>

  <!-- Comprehensive Toolbox -->
  <xml id="toolbox" style="display: none">
    <!-- Robot Connection -->
    <category name="üîå Connection" colour="260">
      <block type="robot_enable_torque"></block>
      <block type="robot_disable_torque"></block>
      <block type="robot_enable_all"></block>
      <block type="robot_disable_all"></block>
      <block type="robot_check_motors"></block>
      <block type="robot_ping_motor"></block>
      <block type="robot_reboot_motor"></block>
      <block type="robot_reboot_all"></block>
    </category>
    
    <!-- Single Joint -->
    <category name="ü¶æ Single Joint" colour="160">
      <block type="robot_set_joint">
        <value name="JOINT"><shadow type="math_number"><field name="NUM">2048</field></shadow></value>
      </block>
      <block type="robot_set_degrees">
        <value name="DEGREES"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
      </block>
      <block type="robot_get_joint"></block>
      <block type="robot_get_degrees"></block>
      <block type="robot_move_by">
        <value name="AMOUNT"><shadow type="math_number"><field name="NUM">100</field></shadow></value>
      </block>
      <block type="robot_move_smooth">
        <value name="JOINT"><shadow type="math_number"><field name="NUM">2048</field></shadow></value>
        <value name="DURATION"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
      </block>
      <block type="robot_set_speed">
        <value name="SPEED"><shadow type="math_number"><field name="NUM">100</field></shadow></value>
      </block>
    </category>
    
    <!-- All Joints -->
    <category name="üîó All Joints" colour="180">
      <block type="robot_get_all_joints"></block>
      <block type="robot_set_all_joints"></block>
      <block type="robot_copy_joint"></block>
    </category>
    
    <!-- Kinematics -->
    <category name="ü¶ø Kinematics" colour="290">
      <block type="robot_joints_to_coordinates"></block>
      <block type="robot_coordinates_to_joints"></block>
      <block type="robot_create_coordinates">
        <value name="X"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="Y"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="Z"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="ROLL"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="PITCH"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="YAW"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
      </block>
      <block type="robot_get_coordinate"></block>
      <block type="robot_get_current_coordinates"></block>
      <block type="robot_joints_to_degrees"></block>
      <block type="robot_degrees_to_joints"></block>
    </category>
    
    <!-- Sensing -->
    <category name="üì° Sensing" colour="210">
      <block type="robot_is_moving"></block>
      <block type="robot_wait_until_stopped">
        <value name="TIMEOUT"><shadow type="math_number"><field name="NUM">5</field></shadow></value>
      </block>
      <block type="robot_get_load"></block>
      <block type="robot_get_temperature"></block>
      <block type="robot_joint_in_range">
        <value name="MIN"><shadow type="math_number"><field name="NUM">1800</field></shadow></value>
        <value name="MAX"><shadow type="math_number"><field name="NUM">2200</field></shadow></value>
      </block>
    </category>
    
    <!-- Timing -->
    <category name="‚è±Ô∏è Timing" colour="120">
      <block type="robot_wait">
        <value name="TIME"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
      </block>
      <block type="robot_wait_ms">
        <value name="TIME"><shadow type="math_number"><field name="NUM">100</field></shadow></value>
      </block>
      <block type="robot_get_time"></block>
      <block type="robot_reset_timer"></block>
      <block type="robot_timer_value"></block>
    </category>
    
    <!-- Output -->
    <category name="üìù Output" colour="60">
      <block type="robot_log">
        <value name="MESSAGE"><shadow type="text"><field name="TEXT">Hello!</field></shadow></value>
      </block>
      <block type="robot_log_joint"></block>
      <block type="robot_log_type"></block>
      <block type="robot_alert">
        <value name="MESSAGE"><shadow type="text"><field name="TEXT">Hello!</field></shadow></value>
      </block>
    </category>

    <sep></sep>
    
    <!-- Logic (Built-in) -->
    <category name="üîÄ Logic" colour="210">
      <block type="controls_if"></block>
      <block type="controls_if">
        <mutation else="1"></mutation>
      </block>
      <block type="controls_if">
        <mutation elseif="1" else="1"></mutation>
      </block>
      <block type="logic_compare"></block>
      <block type="logic_operation"></block>
      <block type="logic_negate"></block>
      <block type="logic_boolean"></block>
      <block type="logic_ternary"></block>
    </category>
    
    <!-- Loops (Built-in) -->
    <category name="üîÅ Loops" colour="120">
      <block type="controls_repeat_ext">
        <value name="TIMES"><shadow type="math_number"><field name="NUM">10</field></shadow></value>
      </block>
      <block type="controls_whileUntil"></block>
      <block type="controls_for">
        <value name="FROM"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
        <value name="TO"><shadow type="math_number"><field name="NUM">10</field></shadow></value>
        <value name="BY"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
      </block>
      <block type="controls_forEach"></block>
      <block type="controls_flow_statements"></block>
    </category>
    
    <!-- Math (Built-in) -->
    <category name="üî¢ Math" colour="230">
      <block type="math_number"><field name="NUM">0</field></block>
      <block type="math_arithmetic"></block>
      <block type="math_single"></block>
      <block type="math_trig"></block>
      <block type="math_constant"></block>
      <block type="math_number_property"></block>
      <block type="math_round"></block>
      <block type="math_on_list"></block>
      <block type="math_modulo"></block>
      <block type="math_constrain">
        <value name="LOW"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
        <value name="HIGH"><shadow type="math_number"><field name="NUM">4095</field></shadow></value>
      </block>
      <block type="math_random_int">
        <value name="FROM"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
        <value name="TO"><shadow type="math_number"><field name="NUM">100</field></shadow></value>
      </block>
      <block type="math_random_float"></block>
      <block type="math_atan2"></block>
    </category>
    
    <!-- Text (Built-in) -->
    <category name="üìÑ Text" colour="160">
      <block type="text"></block>
      <block type="text_join"></block>
      <block type="text_append">
        <value name="TEXT"><shadow type="text"></shadow></value>
      </block>
      <block type="text_length"></block>
      <block type="text_isEmpty"></block>
      <block type="text_indexOf"></block>
      <block type="text_charAt"></block>
      <block type="text_getSubstring"></block>
      <block type="text_changeCase"></block>
      <block type="text_trim"></block>
      <block type="text_prompt_ext">
        <value name="TEXT"><shadow type="text"><field name="TEXT">Enter value:</field></shadow></value>
      </block>
    </category>
    
    <!-- Lists (Built-in) -->
    <category name="üìã Lists" colour="260">
      <block type="lists_create_empty"></block>
      <block type="lists_create_with"></block>
      <block type="lists_repeat">
        <value name="NUM"><shadow type="math_number"><field name="NUM">5</field></shadow></value>
      </block>
      <block type="lists_length"></block>
      <block type="lists_isEmpty"></block>
      <block type="lists_indexOf"></block>
      <block type="lists_getIndex"></block>
      <block type="lists_setIndex"></block>
      <block type="lists_getSublist"></block>
      <block type="lists_split">
        <value name="DELIM"><shadow type="text"><field name="TEXT">,</field></shadow></value>
      </block>
      <block type="lists_sort"></block>
      <block type="lists_reverse"></block>
    </category>
    
    <!-- Variables (Built-in) -->
    <category name="üì¶ Variables" colour="330" custom="VARIABLE"></category>
    
    <!-- Functions (Built-in) -->
    <category name="üß© Functions" colour="290" custom="PROCEDURE"></category>
  </xml>

  <script src="index.js"></script>
  <script>
    // ========== Global State ==========
    var stopRequested = false;
    var programTimer = 0;
    var recordedPoses = {};
    var motorPositionCache = {};

    // ========== Kinematics Functions ==========
    // These call the WASM functions attached to window
    // joints -> coordinates: window.forward_kinematics(joints) -> [x, y, z, roll, pitch, yaw]
    // coordinates -> joints: window.inverse_kinematics(coordinates) -> [j1, j2, ..., j8]

    function callFK(joints) {
      return window.forward_kinematics(joints);
    }

    function callIK(coordinates) {
      return window.inverse_kinematics(coordinates);
    }

    // ========== Console Logging ==========
    function logConsole(message, type) {
      type = type || 'log';
      var el = document.getElementById('consoleOutput');
      var line = document.createElement('div');
      line.className = type;
      var time = new Date().toLocaleTimeString();
      line.textContent = '[' + time + '] ' + message;
      el.appendChild(line);
      el.scrollTop = el.scrollHeight;
      // Also log to browser console
      console.log('[' + type + ']', message);
    }

    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
      document.querySelectorAll('.tab-content').forEach(function(t) { t.classList.remove('active'); });
      document.querySelector('.tab:nth-child(' + (tab === 'code' ? '1' : '2') + ')').classList.add('active');
      document.getElementById(tab + 'Tab').classList.add('active');
    }

    // ========== Robot Communication ==========
    var Robot = {
      port: null,
      reader: null,
      writer: null,
      connected: false,
      readBuffer: [],
      motorIds: [11, 12, 13, 14, 15, 16, 17, 18],

      CRC_TABLE: [
        0x0000, 0x8005, 0x800F, 0x000A, 0x801B, 0x001E, 0x0014, 0x8011,
        0x8033, 0x0036, 0x003C, 0x8039, 0x0028, 0x802D, 0x8027, 0x0022,
        0x8063, 0x0066, 0x006C, 0x8069, 0x0078, 0x807D, 0x8077, 0x0072,
        0x0050, 0x8055, 0x805F, 0x005A, 0x804B, 0x004E, 0x0044, 0x8041,
        0x80C3, 0x00C6, 0x00CC, 0x80C9, 0x00D8, 0x80DD, 0x80D7, 0x00D2,
        0x00F0, 0x80F5, 0x80FF, 0x00FA, 0x80EB, 0x00EE, 0x00E4, 0x80E1,
        0x00A0, 0x80A5, 0x80AF, 0x00AA, 0x80BB, 0x00BE, 0x00B4, 0x80B1,
        0x8093, 0x0096, 0x009C, 0x8099, 0x0088, 0x808D, 0x8087, 0x0082,
        0x8183, 0x0186, 0x018C, 0x8189, 0x0198, 0x819D, 0x8197, 0x0192,
        0x01B0, 0x81B5, 0x81BF, 0x01BA, 0x81AB, 0x01AE, 0x01A4, 0x81A1,
        0x01E0, 0x81E5, 0x81EF, 0x01EA, 0x81FB, 0x01FE, 0x01F4, 0x81F1,
        0x81D3, 0x01D6, 0x01DC, 0x81D9, 0x01C8, 0x81CD, 0x81C7, 0x01C2,
        0x0140, 0x8145, 0x814F, 0x014A, 0x815B, 0x015E, 0x0154, 0x8151,
        0x8173, 0x0176, 0x017C, 0x8179, 0x0168, 0x816D, 0x8167, 0x0162,
        0x8123, 0x0126, 0x012C, 0x8129, 0x0138, 0x813D, 0x8137, 0x0132,
        0x0110, 0x8115, 0x811F, 0x011A, 0x810B, 0x010E, 0x0104, 0x8101,
        0x8303, 0x0306, 0x030C, 0x8309, 0x0318, 0x831D, 0x8317, 0x0312,
        0x0330, 0x8335, 0x833F, 0x033A, 0x832B, 0x032E, 0x0324, 0x8321,
        0x0360, 0x8365, 0x836F, 0x036A, 0x837B, 0x037E, 0x0374, 0x8371,
        0x8353, 0x0356, 0x035C, 0x8359, 0x0348, 0x834D, 0x8347, 0x0342,
        0x03C0, 0x83C5, 0x83CF, 0x03CA, 0x83DB, 0x03DE, 0x03D4, 0x83D1,
        0x83F3, 0x03F6, 0x03FC, 0x83F9, 0x03E8, 0x83ED, 0x83E7, 0x03E2,
        0x83A3, 0x03A6, 0x03AC, 0x83A9, 0x03B8, 0x83BD, 0x83B7, 0x03B2,
        0x0390, 0x8395, 0x839F, 0x039A, 0x838B, 0x038E, 0x0384, 0x8381,
        0x0280, 0x8285, 0x828F, 0x028A, 0x829B, 0x029E, 0x0294, 0x8291,
        0x82B3, 0x02B6, 0x02BC, 0x82B9, 0x02A8, 0x82AD, 0x82A7, 0x02A2,
        0x82E3, 0x02E6, 0x02EC, 0x82E9, 0x02F8, 0x82FD, 0x82F7, 0x02F2,
        0x02D0, 0x82D5, 0x82DF, 0x02DA, 0x82CB, 0x02CE, 0x02C4, 0x82C1,
        0x8243, 0x0246, 0x024C, 0x8249, 0x0258, 0x825D, 0x8257, 0x0252,
        0x0270, 0x8275, 0x827F, 0x027A, 0x826B, 0x026E, 0x0264, 0x8261,
        0x0220, 0x8225, 0x822F, 0x022A, 0x823B, 0x023E, 0x0234, 0x8231,
        0x8213, 0x0216, 0x021C, 0x8219, 0x0208, 0x820D, 0x8207, 0x0202
      ],

      calculateCRC: function(data) {
        var crc = 0;
        for (var j = 0; j < data.length; j++) {
          var i = ((crc >> 8) ^ data[j]) & 0xFF;
          crc = ((crc << 8) ^ this.CRC_TABLE[i]) & 0xFFFF;
        }
        return crc;
      },

      buildPacket: function(id, instruction, params) {
        params = params || [];
        var length = 1 + params.length + 2;
        var packet = [0xFF, 0xFF, 0xFD, 0x00, id, length & 0xFF, (length >> 8) & 0xFF, instruction];
        for (var i = 0; i < params.length; i++) packet.push(params[i]);
        var crc = this.calculateCRC(packet);
        packet.push(crc & 0xFF, (crc >> 8) & 0xFF);
        return new Uint8Array(packet);
      },

      buildWritePacket: function(id, address, data) {
        var params = [address & 0xFF, (address >> 8) & 0xFF];
        for (var i = 0; i < data.length; i++) params.push(data[i]);
        return this.buildPacket(id, 0x03, params);
      },

      buildReadPacket: function(id, address, dataLength) {
        var params = [address & 0xFF, (address >> 8) & 0xFF, dataLength & 0xFF, (dataLength >> 8) & 0xFF];
        return this.buildPacket(id, 0x02, params);
      },

      buildSyncWritePacket: function(address, dataLength, motorData) {
        var n = motorData.length;
        var length = 1 + 2 + 2 + n * (1 + dataLength) + 2;
        var packet = [0xFF, 0xFF, 0xFD, 0x00, 0xFE, length & 0xFF, (length >> 8) & 0xFF, 0x83,
                      address & 0xFF, (address >> 8) & 0xFF, dataLength & 0xFF, (dataLength >> 8) & 0xFF];
        for (var i = 0; i < motorData.length; i++) {
          packet.push(motorData[i].id);
          for (var j = 0; j < motorData[i].data.length; j++) {
            packet.push(motorData[i].data[j]);
          }
        }
        var crc = this.calculateCRC(packet);
        packet.push(crc & 0xFF, (crc >> 8) & 0xFF);
        return new Uint8Array(packet);
      },

      connect: function() {
        var self = this;
        return navigator.serial.requestPort().then(function(p) {
          self.port = p;
          return self.port.open({ baudRate: 1000000 });
        }).then(function() {
          self.writer = self.port.writable.getWriter();
          self.reader = self.port.readable.getReader();
          self.connected = true;
          self.readBuffer = [];
          self.startBackgroundReader();
          updateConnectionStatus(true);
          logConsole('Connected to robot', 'success');
          self.startPositionPolling();
          // Auto-check motors after connection
          setTimeout(function() { checkMotors(); }, 500);
          return true;
        }).catch(function(e) {
          logConsole('Connection failed: ' + e.message, 'error');
          return false;
        });
      },

      disconnect: function() {
        var self = this;
        self.connected = false;
        self.stopPositionPolling();
        return Promise.resolve().then(function() {
          if (self.reader) return self.reader.cancel();
        }).then(function() {
          if (self.reader) self.reader.releaseLock();
          if (self.writer) self.writer.releaseLock();
          if (self.port) return self.port.close();
        }).then(function() {
          self.port = null;
          self.reader = null;
          self.writer = null;
          self.readBuffer = [];
          updateConnectionStatus(false);
          logConsole('Disconnected', 'log');
        }).catch(function() {});
      },

      startBackgroundReader: function() {
        var self = this;
        function readLoop() {
          if (!self.connected || !self.reader) return;
          self.reader.read().then(function(result) {
            if (result.done) return;
            if (result.value) {
              for (var i = 0; i < result.value.length; i++) {
                self.readBuffer.push(result.value[i]);
              }
              if (self.readBuffer.length > 2048) {
                self.readBuffer = self.readBuffer.slice(-1024);
              }
            }
            readLoop();
          }).catch(function() {});
        }
        readLoop();
      },

      pollingInterval: null,
      startPositionPolling: function() {
        var self = this;
        this.pollingInterval = setInterval(function() {
          if (!self.connected) return;
          // Update motor status display with cached positions
          for (var i = 0; i < self.motorIds.length; i++) {
            var id = self.motorIds[i];
            var el = document.getElementById('motor' + id);
            if (el && motorPositionCache[id] !== undefined) {
              var deg = Math.round(self.positionToDegrees(motorPositionCache[id]));
              el.querySelector('span').textContent = deg + '¬∞';
              el.classList.add('active');
            }
          }
        }, 200);
      },

      stopPositionPolling: function() {
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
        }
      },

      waitForPacket: function(motorId, timeout) {
        var self = this;
        timeout = timeout || 200;
        var start = Date.now();
        return new Promise(function(resolve) {
          function check() {
            if (Date.now() - start > timeout) { resolve(null); return; }
            for (var i = 0; i < self.readBuffer.length - 10; i++) {
              if (self.readBuffer[i] === 0xFF && self.readBuffer[i+1] === 0xFF &&
                  self.readBuffer[i+2] === 0xFD && self.readBuffer[i+3] === 0x00) {
                var packetId = self.readBuffer[i+4];
                var len = self.readBuffer[i+5] | (self.readBuffer[i+6] << 8);
                var totalLen = 7 + len;
                if (i + totalLen <= self.readBuffer.length) {
                  if (self.readBuffer[i+7] === 0x55 && packetId === motorId) {
                    var pkt = self.readBuffer.slice(i, i + totalLen);
                    self.readBuffer = self.readBuffer.slice(i + totalLen);
                    resolve(pkt);
                    return;
                  }
                  self.readBuffer = self.readBuffer.slice(i + totalLen);
                  i = -1;
                }
              }
            }
            setTimeout(check, 5);
          }
          check();
        });
      },

      sendPacket: function(packet, expectResponse, motorId) {
        var self = this;
        if (!self.connected || !self.writer) return Promise.resolve(null);
        self.readBuffer = [];
        return self.writer.write(packet).then(function() {
          if (!expectResponse) return new Promise(function(r) { setTimeout(function() { r(null); }, 5); });
          return self.waitForPacket(motorId);
        });
      },

      // High-level API
      
      // Dynamixel error codes
      errorCodes: {
        0x01: 'Result Fail',
        0x02: 'Instruction Error',
        0x04: 'CRC Error',
        0x08: 'Data Range Error',
        0x10: 'Data Length Error',
        0x20: 'Data Limit Error',
        0x40: 'Access Error',
        0x80: 'Hardware Alert'  // Voltage, Overheating, etc.
      },
      
      parseError: function(errorByte) {
        if (errorByte === 0) return null;
        var errors = [];
        for (var code in this.errorCodes) {
          if (errorByte & parseInt(code)) {
            errors.push(this.errorCodes[code]);
          }
        }
        return errors.join(', ');
      },

      // Build REBOOT packet (instruction 0x08)
      buildRebootPacket: function(id) {
        return this.buildPacket(id, 0x08, []);
      },

      // Build PING packet (instruction 0x01)
      buildPingPacket: function(id) {
        return this.buildPacket(id, 0x01, []);
      },

      // Ping a motor to check if it responds
      pingMotor: function(id) {
        var self = this;
        var packet = this.buildPingPacket(id);
        return this.sendPacket(packet, true, id).then(function(response) {
          if (response && response.length >= 11) {
            var error = response[8];
            if (error !== 0) {
              var errorMsg = self.parseError(error);
              return { ok: false, error: errorMsg, hasHardwareAlert: !!(error & 0x80) };
            }
            return { ok: true, error: null };
          }
          return { ok: false, error: 'No response', hasHardwareAlert: false };
        });
      },

      // Check all motors and report status
      checkAllMotors: function() {
        var self = this;
        var results = {};
        var checkNext = function(index) {
          if (index >= self.motorIds.length) {
            return Promise.resolve(results);
          }
          var id = self.motorIds[index];
          return self.pingMotor(id).then(function(result) {
            results[id] = result;
            return checkNext(index + 1);
          });
        };
        return checkNext(0);
      },

      // Reboot a motor (clears hardware error status)
      rebootMotor: function(id) {
        var self = this;
        var packet = this.buildRebootPacket(id);
        logConsole('Rebooting motor ' + id + '...', 'warn');
        return this.sendPacket(packet, false).then(function() {
          // Wait for motor to reboot
          return new Promise(function(r) { setTimeout(r, 500); });
        }).then(function() {
          return self.pingMotor(id);
        }).then(function(result) {
          if (result.ok) {
            logConsole('Motor ' + id + ' rebooted successfully', 'success');
          } else {
            logConsole('Motor ' + id + ' still has error after reboot: ' + result.error, 'error');
          }
          return result;
        });
      },

      // Reboot all motors
      rebootAllMotors: function() {
        var self = this;
        var rebootNext = function(index) {
          if (index >= self.motorIds.length) {
            return Promise.resolve();
          }
          return self.rebootMotor(self.motorIds[index]).then(function() {
            return rebootNext(index + 1);
          });
        };
        return rebootNext(0);
      },

      setTorque: function(id, enable) {
        var self = this;
        var packet = this.buildWritePacket(id, 64, [enable ? 1 : 0]);
        return this.sendPacket(packet, true, id).then(function(response) {
          if (response && response.length >= 11) {
            var error = response[8];
            if (error !== 0) {
              var errorMsg = self.parseError(error);
              logConsole('Motor ' + id + ' torque error: ' + errorMsg, 'error');
              if (error & 0x80) {
                logConsole('Motor ' + id + ' has hardware alert - try rebooting', 'warn');
              }
              return false;
            }
            return true;
          } else {
            logConsole('Motor ' + id + ' not responding', 'error');
            return false;
          }
        });
      },

      setTorqueMultiple: function(ids, enable) {
        var self = this;
        var results = { success: [], failed: [] };
        var setNext = function(index) {
          if (index >= ids.length) {
            return Promise.resolve(results);
          }
          return self.setTorque(ids[index], enable).then(function(ok) {
            if (ok) {
              results.success.push(ids[index]);
            } else {
              results.failed.push(ids[index]);
            }
            return setNext(index + 1);
          });
        };
        return setNext(0).then(function(results) {
          if (results.failed.length > 0) {
            logConsole('Failed to set torque on motors: ' + results.failed.join(', '), 'error');
          }
          return results;
        });
      },

      setPosition: function(id, position) {
        var pos = Math.round(position);
        var posUint = pos < 0 ? pos + 0x100000000 : pos;
        var data = [posUint & 0xFF, (posUint >> 8) & 0xFF, (posUint >> 16) & 0xFF, (posUint >> 24) & 0xFF];
        var packet = this.buildWritePacket(id, 116, data);
        motorPositionCache[id] = pos;
        return this.sendPacket(packet, false);
      },

      setPositionMultiple: function(ids, positions) {
        var motorData = [];
        for (var i = 0; i < ids.length; i++) {
          var pos = Math.round(positions[i]);
          var posUint = pos < 0 ? pos + 0x100000000 : pos;
          motorData.push({
            id: ids[i],
            data: [posUint & 0xFF, (posUint >> 8) & 0xFF, (posUint >> 16) & 0xFF, (posUint >> 24) & 0xFF]
          });
          motorPositionCache[ids[i]] = pos;
        }
        var packet = this.buildSyncWritePacket(116, 4, motorData);
        return this.sendPacket(packet, false);
      },

      getPosition: function(id) {
        var self = this;
        var packet = this.buildReadPacket(id, 132, 4);
        return this.sendPacket(packet, true, id).then(function(response) {
          if (response && response.length >= 15) {
            var pos = response[9] | (response[10] << 8) | (response[11] << 16) | (response[12] << 24);
            if (pos > 0x7FFFFFFF) pos -= 0x100000000;
            motorPositionCache[id] = pos;
            return pos;
          }
          return motorPositionCache[id] || 2048;
        });
      },

      moveSmooth: function(id, targetPos, durationMs) {
        var self = this;
        return self.getPosition(id).then(function(startPos) {
          var steps = Math.max(10, Math.floor(durationMs / 20));
          var stepDelay = durationMs / steps;
          var delta = targetPos - startPos;
          
          function doStep(step) {
            if (step > steps || stopRequested) return Promise.resolve();
            var t = step / steps;
            // Ease in-out
            t = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            var pos = Math.round(startPos + delta * t);
            return self.setPosition(id, pos).then(function() {
              return new Promise(function(r) { setTimeout(r, stepDelay); });
            }).then(function() {
              return doStep(step + 1);
            });
          }
          return doStep(1);
        });
      },

      degreesToPosition: function(deg) {
        return Math.round(2048 + (deg * 4096 / 360));
      },

      positionToDegrees: function(pos) {
        return (pos - 2048) * 360 / 4096;
      },

      // Max speed: 1 rotation per second = 4096 steps/sec (360¬∞ per second)
      maxStepsPerSecond: 4096,
      stepIntervalMs: 20, // Send commands every 20ms

      // Speed-limited single motor move
      setPositionLimited: function(id, targetPos) {
        var self = this;

        // Get current position - read from motor if not cached
        function getStartPos() {
          if (motorPositionCache[id] !== undefined) {
            return Promise.resolve(motorPositionCache[id]);
          }
          return self.getPosition(id);
        }

        return getStartPos().then(function(startPos) {
          var delta = Math.abs(targetPos - startPos);

          // Calculate duration based on max speed
          var durationMs = (delta / self.maxStepsPerSecond) * 1000;
          if (durationMs < 50) {
            // Very small move, just do it directly
            return self.setPosition(id, targetPos);
          }

          var steps = Math.max(2, Math.floor(durationMs / self.stepIntervalMs));
          var stepDelay = durationMs / steps;
          var direction = targetPos > startPos ? 1 : -1;
          var stepSize = delta / steps;

          function doStep(step) {
            if (step > steps || stopRequested) return Promise.resolve();
            var pos = Math.round(startPos + direction * stepSize * step);
            return self.setPosition(id, pos).then(function() {
              return new Promise(function(r) { setTimeout(r, stepDelay); });
            }).then(function() {
              return doStep(step + 1);
            });
          }
          return doStep(1);
        });
      },

      // Speed-limited multi-motor move (all motors move together, speed limited by slowest)
      setPositionMultipleLimited: function(ids, positions) {
        var self = this;

        // First, get all current positions (read from motor if not cached)
        var positionPromises = ids.map(function(id) {
          if (motorPositionCache[id] !== undefined) {
            return Promise.resolve(motorPositionCache[id]);
          }
          return self.getPosition(id);
        });

        return Promise.all(positionPromises).then(function(startPositions) {
          // Calculate deltas and find max
          var maxDelta = 0;
          for (var i = 0; i < ids.length; i++) {
            var delta = Math.abs(positions[i] - startPositions[i]);
            if (delta > maxDelta) maxDelta = delta;
          }

          // Calculate duration based on the motor that needs to move the most
          var durationMs = (maxDelta / self.maxStepsPerSecond) * 1000;
          if (durationMs < 50) {
            // Very small move, just do it directly
            return self.setPositionMultiple(ids, positions);
          }

          var steps = Math.max(2, Math.floor(durationMs / self.stepIntervalMs));
          var stepDelay = durationMs / steps;

          function doStep(step) {
            if (step > steps || stopRequested) return Promise.resolve();
            var t = step / steps;
            var currentPositions = [];
            for (var i = 0; i < ids.length; i++) {
              currentPositions.push(Math.round(startPositions[i] + (positions[i] - startPositions[i]) * t));
            }
            return self.setPositionMultiple(ids, currentPositions).then(function() {
              return new Promise(function(r) { setTimeout(r, stepDelay); });
            }).then(function() {
              return doStep(step + 1);
            });
          }
          return doStep(1);
        });
      }
    };

    // ========== UI Functions ==========
    function updateConnectionStatus(connected) {
      document.getElementById('statusDot').className = 'status-dot' + (connected ? ' connected' : '');
      document.getElementById('statusText').textContent = connected ? 'Connected' : 'Disconnected';
      document.getElementById('connectBtn').textContent = connected ? 'üîå Disconnect' : 'üîå Connect';
      
      // Reset motor badges
      if (!connected) {
        Robot.motorIds.forEach(function(id) {
          var el = document.getElementById('motor' + id);
          if (el) {
            el.querySelector('span').textContent = '--';
            el.classList.remove('active');
          }
        });
      }
    }

    function toggleConnection() {
      if (Robot.connected) {
        Robot.disconnect();
      } else {
        Robot.connect();
      }
    }

    function enableAllTorque() {
      if (!Robot.connected) { logConsole('Not connected', 'error'); return; }
      Robot.setTorqueMultiple(Robot.motorIds, true).then(function(results) {
        if (results.failed.length === 0) {
          logConsole('All motors enabled', 'success');
        }
      });
    }

    function disableAllTorque() {
      if (!Robot.connected) { logConsole('Not connected', 'error'); return; }
      Robot.setTorqueMultiple(Robot.motorIds, false).then(function(results) {
        if (results.failed.length === 0) {
          logConsole('All motors disabled', 'success');
        }
      });
    }

    function checkMotors() {
      if (!Robot.connected) { logConsole('Not connected', 'error'); return; }
      logConsole('Checking all motors...', 'info');
      Robot.checkAllMotors().then(function(results) {
        var ok = [];
        var failed = [];
        var alerts = [];
        for (var id in results) {
          var el = document.getElementById('motor' + id);
          if (results[id].ok) {
            ok.push(id);
            if (el) {
              el.classList.remove('error');
              el.classList.add('active');
            }
          } else {
            failed.push(id);
            if (el) {
              el.classList.add('error');
              el.classList.remove('active');
            }
            if (results[id].hasHardwareAlert) {
              alerts.push(id);
            }
          }
        }
        if (failed.length === 0) {
          logConsole('All ' + ok.length + ' motors OK', 'success');
        } else {
          logConsole('Motors OK: ' + ok.join(', '), 'success');
          logConsole('Motors FAILED: ' + failed.join(', '), 'error');
          if (alerts.length > 0) {
            logConsole('Motors with hardware alert (need reboot): ' + alerts.join(', '), 'warn');
          }
        }
      });
    }

    function rebootAllMotors() {
      if (!Robot.connected) { logConsole('Not connected', 'error'); return; }
      if (!confirm('Reboot all motors? This will clear hardware errors but motors will lose torque.')) return;
      logConsole('Rebooting all motors...', 'warn');
      Robot.rebootAllMotors().then(function() {
        logConsole('All motors rebooted', 'success');
        checkMotors();
      });
    }

    function runCode() {
      if (!Robot.connected) {
        logConsole('Please connect to the robot first', 'error');
        return;
      }
      stopRequested = false;
      programTimer = Date.now();
      var code = Blockly.JavaScript.workspaceToCode(workspace);
      if (!code.trim()) {
        logConsole('No blocks to run', 'error');
        return;
      }
      logConsole('Running program...', 'success');
      switchTab('console');
      var asyncCode = '(async function() { ' + code + ' })()';
      eval(asyncCode).then(function() {
        if (!stopRequested) logConsole('Program completed (' + ((Date.now() - programTimer)/1000).toFixed(1) + 's)', 'success');
      }).catch(function(e) {
        logConsole('Error: ' + e.message, 'error');
        console.error(e);
      });
    }

    function stopCode() {
      stopRequested = true;
      logConsole('Program stopped', 'warn');
    }

    function saveWorkspace() {
      var xml = Blockly.Xml.workspaceToDom(workspace);
      var xmlText = Blockly.Xml.domToText(xml);
      var blob = new Blob([xmlText], {type: 'text/xml'});
      var a = document.createElement('a');
      a.download = 'reachy-program.xml';
      a.href = URL.createObjectURL(blob);
      a.click();
      logConsole('Workspace saved', 'success');
    }

    function loadWorkspace() {
      var input = document.createElement('input');
      input.type = 'file';
      input.accept = '.xml';
      input.onchange = function(e) {
        var file = e.target.files[0];
        var reader = new FileReader();
        reader.onload = function(e) {
          var xml = Blockly.utils.xml.textToDom(e.target.result);
          Blockly.Xml.clearWorkspaceAndLoadFromXml(xml, workspace);
          logConsole('Workspace loaded', 'success');
        };
        reader.readAsText(file);
      };
      input.click();
    }

    // ========== Custom Blocks ==========
    var MOTORS = [['17','17'],['18','18'],['11','11'],['12','12'],['13','13'],['14','14'],['15','15'],['16','16']];
    var LOG_TYPES = [['info','info'],['success','success'],['warning','warn'],['error','error']];

    // === Connection Blocks ===
    Blockly.Blocks['robot_enable_torque'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('enable torque joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(260);
        this.setTooltip('Enable torque for a single joint');
      }
    };
    Blockly.JavaScript.forBlock['robot_enable_torque'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      return 'await Robot.setTorque(' + motor + ', true);\n';
    };

    Blockly.Blocks['robot_disable_torque'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('disable torque joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(260);
        this.setTooltip('Disable torque for a single joint');
      }
    };
    Blockly.JavaScript.forBlock['robot_disable_torque'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      return 'await Robot.setTorque(' + motor + ', false);\n';
    };

    Blockly.Blocks['robot_enable_all'] = {
      init: function() {
        this.appendDummyInput().appendField('enable all joints');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(260);
      }
    };
    Blockly.JavaScript.forBlock['robot_enable_all'] = function(block) {
      return 'await Robot.setTorqueMultiple(Robot.motorIds, true);\n';
    };

    Blockly.Blocks['robot_disable_all'] = {
      init: function() {
        this.appendDummyInput().appendField('disable all joints');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(260);
      }
    };
    Blockly.JavaScript.forBlock['robot_disable_all'] = function(block) {
      return 'await Robot.setTorqueMultiple(Robot.motorIds, false);\n';
    };

    Blockly.Blocks['robot_check_motors'] = {
      init: function() {
        this.appendDummyInput().appendField('check all joints');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(260);
        this.setTooltip('Ping all joints, read positions, and log their status');
      }
    };
    Blockly.JavaScript.forBlock['robot_check_motors'] = function(block) {
      return 'await (async function() { var results = await Robot.checkAllMotors(); var ok = [], failed = []; for (var id in results) { if (results[id].ok) ok.push(id); else failed.push(id); } if (failed.length === 0) { logConsole("All " + ok.length + " joints OK", "success"); for (var i = 0; i < Robot.motorIds.length; i++) { var id = Robot.motorIds[i]; var pos = await Robot.getPosition(id); var deg = Robot.positionToDegrees(pos).toFixed(1); logConsole("Joint " + id + ": " + pos + " (" + deg + "¬∞)", "info"); } } else { logConsole("OK: " + ok.join(", ") + " | FAILED: " + failed.join(", "), "error"); } })();\n';
    };

    Blockly.Blocks['robot_ping_motor'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('is responding');
        this.setOutput(true, 'Boolean');
        this.setColour(260);
        this.setTooltip('Check if a joint responds to ping');
      }
    };
    Blockly.JavaScript.forBlock['robot_ping_motor'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      return ['(await Robot.pingMotor(' + motor + ')).ok', Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_reboot_motor'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('reboot joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(260);
        this.setTooltip('Reboot joint to clear hardware errors');
      }
    };
    Blockly.JavaScript.forBlock['robot_reboot_motor'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      return 'await Robot.rebootMotor(' + motor + ');\n';
    };

    Blockly.Blocks['robot_reboot_all'] = {
      init: function() {
        this.appendDummyInput().appendField('reboot all joints');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(260);
        this.setTooltip('Reboot all joints to clear hardware errors');
      }
    };
    Blockly.JavaScript.forBlock['robot_reboot_all'] = function(block) {
      return 'await Robot.rebootAllMotors();\n';
    };

    // === Joint Blocks ===
    Blockly.Blocks['robot_set_joint'] = {
      init: function() {
        this.appendValueInput('JOINT').setCheck('Number')
            .appendField('set joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('to');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip('Set joint value (0-4095, center=2048)');
      }
    };
    Blockly.JavaScript.forBlock['robot_set_joint'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      var joint = Blockly.JavaScript.valueToCode(block, 'JOINT', Blockly.JavaScript.ORDER_ATOMIC) || '2048';
      return 'await Robot.setPositionLimited(' + motor + ', ' + joint + ');\n';
    };

    Blockly.Blocks['robot_set_degrees'] = {
      init: function() {
        this.appendValueInput('DEGREES').setCheck('Number')
            .appendField('set joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('to');
        this.appendDummyInput().appendField('degrees');
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip('Set joint angle in degrees (0 = center)');
      }
    };
    Blockly.JavaScript.forBlock['robot_set_degrees'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      var deg = Blockly.JavaScript.valueToCode(block, 'DEGREES', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      return 'await Robot.setPositionLimited(' + motor + ', Robot.degreesToPosition(' + deg + '));\n';
    };

    Blockly.Blocks['robot_get_joint'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('value of joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setOutput(true, 'Number');
        this.setColour(160);
      }
    };
    Blockly.JavaScript.forBlock['robot_get_joint'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      return ['await Robot.getPosition(' + motor + ')', Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_get_degrees'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('degrees of joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setOutput(true, 'Number');
        this.setColour(160);
      }
    };
    Blockly.JavaScript.forBlock['robot_get_degrees'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      return ['Robot.positionToDegrees(await Robot.getPosition(' + motor + '))', Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_move_by'] = {
      init: function() {
        this.appendValueInput('AMOUNT').setCheck('Number')
            .appendField('move joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('by');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip('Move joint by relative amount');
      }
    };
    Blockly.JavaScript.forBlock['robot_move_by'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      var amount = Blockly.JavaScript.valueToCode(block, 'AMOUNT', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      return 'await Robot.setPositionLimited(' + motor + ', (await Robot.getPosition(' + motor + ')) + (' + amount + '));\n';
    };

    Blockly.Blocks['robot_move_smooth'] = {
      init: function() {
        this.appendValueInput('JOINT').setCheck('Number')
            .appendField('smooth move joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('to');
        this.appendValueInput('DURATION').setCheck('Number').appendField('over');
        this.appendDummyInput().appendField('seconds');
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip('Smoothly move joint to value over time');
      }
    };
    Blockly.JavaScript.forBlock['robot_move_smooth'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      var joint = Blockly.JavaScript.valueToCode(block, 'JOINT', Blockly.JavaScript.ORDER_ATOMIC) || '2048';
      var dur = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      return 'await Robot.moveSmooth(' + motor + ', ' + joint + ', ' + dur + ' * 1000);\n';
    };

    Blockly.Blocks['robot_set_speed'] = {
      init: function() {
        this.appendValueInput('SPEED').setCheck('Number')
            .appendField('set joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('speed to');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(160);
        this.setTooltip('Set joint velocity limit (0-1023)');
      }
    };
    Blockly.JavaScript.forBlock['robot_set_speed'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      var speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC) || '100';
      // Address 112 = Profile Velocity
      return 'await Robot.sendPacket(Robot.buildWritePacket(' + motor + ', 112, [' + speed + ' & 0xFF, (' + speed + ' >> 8) & 0xFF, (' + speed + ' >> 16) & 0xFF, (' + speed + ' >> 24) & 0xFF]), false);\n';
    };

    // === Multi-Motor Blocks ===
    
    Blockly.Blocks['robot_get_all_joints'] = {
      init: function() {
        this.appendDummyInput().appendField('get all joints as list');
        this.setOutput(true, 'Array');
        this.setColour(180);
        this.setTooltip('Returns list of joint values for motors 11-18');
      }
    };
    Blockly.JavaScript.forBlock['robot_get_all_joints'] = function(block) {
      var code = '(await (async function() { var joints = []; for (var i = 0; i < Robot.motorIds.length; i++) { joints.push(await Robot.getPosition(Robot.motorIds[i])); } return joints; })())';
      return [code, Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_set_all_joints'] = {
      init: function() {
        this.appendValueInput('JOINTS').setCheck('Array')
            .appendField('set all joints from list');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(180);
        this.setTooltip('Set motors 11-18 from a list of 8 joint values');
      }
    };
    Blockly.JavaScript.forBlock['robot_set_all_joints'] = function(block) {
      var joints = Blockly.JavaScript.valueToCode(block, 'JOINTS', Blockly.JavaScript.ORDER_ATOMIC) || '[]';
      return 'await Robot.setPositionMultipleLimited(Robot.motorIds, ' + joints + ');\n';
    };

    Blockly.Blocks['robot_copy_joint'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('copy joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'FROM')
            .appendField('to joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'TO');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(180);
      }
    };
    Blockly.JavaScript.forBlock['robot_copy_joint'] = function(block) {
      var from = block.getFieldValue('FROM');
      var to = block.getFieldValue('TO');
      return 'await Robot.setPositionLimited(' + to + ', await Robot.getPosition(' + from + '));\n';
    };

    // === Kinematics Blocks ===

    var COORDINATE_COMPONENTS = [['x','0'],['y','1'],['z','2'],['roll','3'],['pitch','4'],['yaw','5']];

    Blockly.Blocks['robot_joints_to_coordinates'] = {
      init: function() {
        this.appendValueInput('JOINTS').setCheck('Array')
            .appendField('joints to coordinates');
        this.setOutput(true, 'Array');
        this.setColour(290);
        this.setTooltip('Convert a list of 8 joint angles IN DEGREES to coordinates [x, y, z, roll, pitch, yaw]. Use "joints to degrees" first if you have raw joint values.');
        this.setHelpUrl('');
      }
    };
    Blockly.JavaScript.forBlock['robot_joints_to_coordinates'] = function(block) {
      var joints = Blockly.JavaScript.valueToCode(block, 'JOINTS', Blockly.JavaScript.ORDER_ATOMIC) || '[]';
      return ['callFK(' + joints + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
    };

    Blockly.Blocks['robot_coordinates_to_joints'] = {
      init: function() {
        this.appendValueInput('COORDINATES').setCheck('Array')
            .appendField('coordinates to joints');
        this.setOutput(true, 'Array');
        this.setColour(290);
        this.setTooltip('Convert coordinates [x, y, z, roll, pitch, yaw] to a list of 8 joint angles IN DEGREES. Use "degrees to joints" after if you need raw joint values.');
      }
    };
    Blockly.JavaScript.forBlock['robot_coordinates_to_joints'] = function(block) {
      var coordinates = Blockly.JavaScript.valueToCode(block, 'COORDINATES', Blockly.JavaScript.ORDER_ATOMIC) || '[0,0,0,0,0,0]';
      return ['callIK(' + coordinates + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
    };

    Blockly.Blocks['robot_create_coordinates'] = {
      init: function() {
        this.appendDummyInput().appendField('create coordinates');
        this.appendValueInput('X').setCheck('Number').appendField('x');
        this.appendValueInput('Y').setCheck('Number').appendField('y');
        this.appendValueInput('Z').setCheck('Number').appendField('z');
        this.appendValueInput('ROLL').setCheck('Number').appendField('roll');
        this.appendValueInput('PITCH').setCheck('Number').appendField('pitch');
        this.appendValueInput('YAW').setCheck('Number').appendField('yaw');
        this.setInputsInline(true);
        this.setOutput(true, 'Array');
        this.setColour(290);
        this.setTooltip('Create a coordinates list [x, y, z, roll, pitch, yaw]. x/y/z are position in mm, roll/pitch/yaw are rotation in degrees.');
      }
    };
    Blockly.JavaScript.forBlock['robot_create_coordinates'] = function(block) {
      var x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var z = Blockly.JavaScript.valueToCode(block, 'Z', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var roll = Blockly.JavaScript.valueToCode(block, 'ROLL', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var pitch = Blockly.JavaScript.valueToCode(block, 'PITCH', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var yaw = Blockly.JavaScript.valueToCode(block, 'YAW', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      return ['[' + x + ', ' + y + ', ' + z + ', ' + roll + ', ' + pitch + ', ' + yaw + ']', Blockly.JavaScript.ORDER_ATOMIC];
    };

    Blockly.Blocks['robot_get_coordinate'] = {
      init: function() {
        this.appendValueInput('COORDINATES').setCheck('Array')
            .appendField('get')
            .appendField(new Blockly.FieldDropdown(COORDINATE_COMPONENTS), 'COMPONENT')
            .appendField('from coordinates');
        this.setOutput(true, 'Number');
        this.setColour(290);
        this.setTooltip('Extract a single value from coordinates: x/y/z (position in mm) or roll/pitch/yaw (rotation in degrees).');
      }
    };
    Blockly.JavaScript.forBlock['robot_get_coordinate'] = function(block) {
      var component = block.getFieldValue('COMPONENT');
      var coordinates = Blockly.JavaScript.valueToCode(block, 'COORDINATES', Blockly.JavaScript.ORDER_MEMBER) || '[0,0,0,0,0,0]';
      return ['(' + coordinates + ')[' + component + ']', Blockly.JavaScript.ORDER_MEMBER];
    };

    Blockly.Blocks['robot_get_current_coordinates'] = {
      init: function() {
        this.appendDummyInput().appendField('get current coordinates');
        this.setOutput(true, 'Array');
        this.setColour(290);
        this.setTooltip('Get the robot\'s current position as coordinates [x, y, z, roll, pitch, yaw]. Reads all joints and converts to coordinates.');
      }
    };
    Blockly.JavaScript.forBlock['robot_get_current_coordinates'] = function(block) {
      var code = '(await (async function() { var joints = []; for (var i = 0; i < Robot.motorIds.length; i++) { joints.push(Robot.positionToDegrees(await Robot.getPosition(Robot.motorIds[i]))); } return callFK(joints); })())';
      return [code, Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_joints_to_degrees'] = {
      init: function() {
        this.appendValueInput('JOINTS').setCheck('Array')
            .appendField('joints to degrees');
        this.setOutput(true, 'Array');
        this.setColour(290);
        this.setTooltip('Convert a list of raw joint values (0-4095) to degrees (-180 to 180). Center position 2048 = 0 degrees.');
      }
    };
    Blockly.JavaScript.forBlock['robot_joints_to_degrees'] = function(block) {
      var joints = Blockly.JavaScript.valueToCode(block, 'JOINTS', Blockly.JavaScript.ORDER_ATOMIC) || '[]';
      return ['(' + joints + ').map(function(p) { return Robot.positionToDegrees(p); })', Blockly.JavaScript.ORDER_FUNCTION_CALL];
    };

    Blockly.Blocks['robot_degrees_to_joints'] = {
      init: function() {
        this.appendValueInput('DEGREES').setCheck('Array')
            .appendField('degrees to joints');
        this.setOutput(true, 'Array');
        this.setColour(290);
        this.setTooltip('Convert a list of degrees (-180 to 180) to raw joint values (0-4095). 0 degrees = center position 2048.');
      }
    };
    Blockly.JavaScript.forBlock['robot_degrees_to_joints'] = function(block) {
      var degrees = Blockly.JavaScript.valueToCode(block, 'DEGREES', Blockly.JavaScript.ORDER_ATOMIC) || '[]';
      return ['(' + degrees + ').map(function(d) { return Robot.degreesToPosition(d); })', Blockly.JavaScript.ORDER_FUNCTION_CALL];
    };

    // === Sensing Blocks ===
    Blockly.Blocks['robot_is_moving'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('is moving');
        this.setOutput(true, 'Boolean');
        this.setColour(210);
      }
    };
    Blockly.JavaScript.forBlock['robot_is_moving'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      // Check if position changed from cached value
      return ['(Math.abs((await Robot.getPosition(' + motor + ')) - (motorPositionCache[' + motor + '] || 2048)) > 10)', Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_wait_until_stopped'] = {
      init: function() {
        this.appendValueInput('TIMEOUT').setCheck('Number')
            .appendField('wait until joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('stopped, timeout');
        this.appendDummyInput().appendField('seconds');
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(210);
      }
    };
    Blockly.JavaScript.forBlock['robot_wait_until_stopped'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      var timeout = Blockly.JavaScript.valueToCode(block, 'TIMEOUT', Blockly.JavaScript.ORDER_ATOMIC) || '5';
      return 'var _start = Date.now(); var _lastPos = await Robot.getPosition(' + motor + '); while (Date.now() - _start < ' + timeout + ' * 1000) { await new Promise(function(r) { setTimeout(r, 50); }); var _newPos = await Robot.getPosition(' + motor + '); if (Math.abs(_newPos - _lastPos) < 5) break; _lastPos = _newPos; }\n';
    };

    Blockly.Blocks['robot_get_load'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('load of joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setOutput(true, 'Number');
        this.setColour(210);
        this.setTooltip('Get joint current load (-1000 to 1000)');
      }
    };
    Blockly.JavaScript.forBlock['robot_get_load'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      // Address 126 = Present Load
      return ['(await (async function() { var pkt = Robot.buildReadPacket(' + motor + ', 126, 2); var resp = await Robot.sendPacket(pkt, true, ' + motor + '); if (resp && resp.length >= 13) { var load = resp[9] | (resp[10] << 8); if (load > 32767) load -= 65536; return load; } return 0; })())', Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_get_temperature'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('temperature of joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setOutput(true, 'Number');
        this.setColour(210);
        this.setTooltip('Get joint temperature in ¬∞C');
      }
    };
    Blockly.JavaScript.forBlock['robot_get_temperature'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      // Address 146 = Present Temperature
      return ['(await (async function() { var pkt = Robot.buildReadPacket(' + motor + ', 146, 1); var resp = await Robot.sendPacket(pkt, true, ' + motor + '); if (resp && resp.length >= 12) { return resp[9]; } return 0; })())', Blockly.JavaScript.ORDER_AWAIT];
    };

    Blockly.Blocks['robot_joint_in_range'] = {
      init: function() {
        this.appendValueInput('MIN').setCheck('Number')
            .appendField('joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR')
            .appendField('between');
        this.appendValueInput('MAX').setCheck('Number').appendField('and');
        this.setInputsInline(true);
        this.setOutput(true, 'Boolean');
        this.setColour(210);
      }
    };
    Blockly.JavaScript.forBlock['robot_joint_in_range'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      var min = Blockly.JavaScript.valueToCode(block, 'MIN', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var max = Blockly.JavaScript.valueToCode(block, 'MAX', Blockly.JavaScript.ORDER_ATOMIC) || '4095';
      return ['(function() { var j = motorPositionCache[' + motor + '] || 2048; return j >= ' + min + ' && j <= ' + max + '; })()', Blockly.JavaScript.ORDER_FUNCTION_CALL];
    };

    // === Timing Blocks ===
    Blockly.Blocks['robot_wait'] = {
      init: function() {
        this.appendValueInput('TIME').setCheck('Number').appendField('wait');
        this.appendDummyInput().appendField('seconds');
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(120);
      }
    };
    Blockly.JavaScript.forBlock['robot_wait'] = function(block) {
      var time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      return 'await new Promise(function(r) { setTimeout(r, ' + time + ' * 1000); });\n';
    };

    Blockly.Blocks['robot_wait_ms'] = {
      init: function() {
        this.appendValueInput('TIME').setCheck('Number').appendField('wait');
        this.appendDummyInput().appendField('milliseconds');
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(120);
      }
    };
    Blockly.JavaScript.forBlock['robot_wait_ms'] = function(block) {
      var time = Blockly.JavaScript.valueToCode(block, 'TIME', Blockly.JavaScript.ORDER_ATOMIC) || '100';
      return 'await new Promise(function(r) { setTimeout(r, ' + time + '); });\n';
    };

    Blockly.Blocks['robot_get_time'] = {
      init: function() {
        this.appendDummyInput().appendField('current time (ms)');
        this.setOutput(true, 'Number');
        this.setColour(120);
      }
    };
    Blockly.JavaScript.forBlock['robot_get_time'] = function(block) {
      return ['Date.now()', Blockly.JavaScript.ORDER_FUNCTION_CALL];
    };

    Blockly.Blocks['robot_reset_timer'] = {
      init: function() {
        this.appendDummyInput().appendField('reset timer');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(120);
      }
    };
    Blockly.JavaScript.forBlock['robot_reset_timer'] = function(block) {
      return 'programTimer = Date.now();\n';
    };

    Blockly.Blocks['robot_timer_value'] = {
      init: function() {
        this.appendDummyInput().appendField('timer (seconds)');
        this.setOutput(true, 'Number');
        this.setColour(120);
      }
    };
    Blockly.JavaScript.forBlock['robot_timer_value'] = function(block) {
      return ['((Date.now() - programTimer) / 1000)', Blockly.JavaScript.ORDER_DIVISION];
    };

    // === Output Blocks ===
    Blockly.Blocks['robot_log'] = {
      init: function() {
        this.appendValueInput('MESSAGE').appendField('log');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(60);
      }
    };
    Blockly.JavaScript.forBlock['robot_log'] = function(block) {
      var msg = Blockly.JavaScript.valueToCode(block, 'MESSAGE', Blockly.JavaScript.ORDER_ATOMIC) || '""';
      return 'logConsole(' + msg + ');\n';
    };

    Blockly.Blocks['robot_log_joint'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('log joint')
            .appendField(new Blockly.FieldDropdown(MOTORS), 'MOTOR');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(60);
      }
    };
    Blockly.JavaScript.forBlock['robot_log_joint'] = function(block) {
      var motor = block.getFieldValue('MOTOR');
      return 'logConsole("Joint ' + motor + ': " + (await Robot.getPosition(' + motor + ')) + " (" + Robot.positionToDegrees(await Robot.getPosition(' + motor + ')).toFixed(1) + "¬∞)", "info");\n';
    };

    Blockly.Blocks['robot_log_type'] = {
      init: function() {
        this.appendValueInput('MESSAGE').appendField('log');
        this.appendDummyInput()
            .appendField('as')
            .appendField(new Blockly.FieldDropdown(LOG_TYPES), 'TYPE');
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(60);
      }
    };
    Blockly.JavaScript.forBlock['robot_log_type'] = function(block) {
      var msg = Blockly.JavaScript.valueToCode(block, 'MESSAGE', Blockly.JavaScript.ORDER_ATOMIC) || '""';
      var type = block.getFieldValue('TYPE');
      return 'logConsole(' + msg + ', "' + type + '");\n';
    };

    Blockly.Blocks['robot_alert'] = {
      init: function() {
        this.appendValueInput('MESSAGE').appendField('alert');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(60);
        this.setTooltip('Show a popup alert message');
      }
    };
    Blockly.JavaScript.forBlock['robot_alert'] = function(block) {
      var msg = Blockly.JavaScript.valueToCode(block, 'MESSAGE', Blockly.JavaScript.ORDER_ATOMIC) || '""';
      return 'alert(' + msg + ');\n';
    };

    // ========== Workspace ==========
    var workspace = Blockly.inject('blocklyDiv', {
      toolbox: document.getElementById('toolbox'),
      grid: { spacing: 20, length: 3, colour: '#2a2a4a', snap: true },
      zoom: { controls: true, startScale: 1.0, maxScale: 2, minScale: 0.5, scaleSpeed: 1.1 },
      trashcan: true,
      move: { scrollbars: true, drag: true, wheel: true }
    });

    workspace.addChangeListener(function() {
      var code = Blockly.JavaScript.workspaceToCode(workspace);
      document.getElementById('codeOutput').textContent = code || '// Drag blocks here...';
    });

    logConsole('Ready! Connect to your robot to start.', 'info');
    logConsole('Tip: Use Save/Load to keep your programs', 'info');
  </script>
</body>
</html>
